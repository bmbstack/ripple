package scripts

import (
	"fmt"
	"github.com/bmbstack/ripple/cmd/ripple/logger"
	"github.com/bmbstack/ripple/cmd/ripple/utils"
	"github.com/bmbstack/ripple/rst"
	"github.com/dave/dst"
	"github.com/dave/dst/decorator/resolver/guess"
	"go/token"
	"golang.org/x/mod/modfile"
	"io/fs"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
)

func Generate(currentPath string) {
	logger.Logger.Info("generate code (*.pb.go, *.controller.go, *.service.go) ...")
	appPkg, err := getAppPkg()
	if err != nil {
		logger.Logger.Error(fmt.Sprintf("parse go.mod err: %v", err))
		logger.Logger.Error("Please execute the command `ripple g` under the same level directory of go.mod")
		return
	}
	logger.Logger.Notice(fmt.Sprintf("the project package: %s", appPkg))

	generatePb(currentPath)
	generateCtlService(currentPath)
	logger.Logger.Notice("auto generate file finish")
}

func generatePb(currentPath string) {
	goPathArray := strings.Split(os.Getenv("GOPATH"), ":")
	goPath := goPathArray[0]

	list := collect(currentPath, ".proto")
	for _, item := range list {
		logger.Logger.Info(fmt.Sprintf("auto generate *.pb.go, ref file: %s", item.Path))
		cmd := fmt.Sprintf("protoc -I.:%s/src --gofast_out=plugins=ripple:. %s", goPath, item.Path)
		logger.Logger.Debug(fmt.Sprintf("Run command: %s", cmd))
		out, err := RunCommand("bash", "-c", cmd)
		logger.Logger.Info(fmt.Sprintf("protoc gen out: %s", string(out)))
		if err != nil {
			logger.Logger.Error(fmt.Sprintf("protoc gen err: %s", err.Error()))
		} else {
			logger.Logger.Notice("protoc gen success")
		}
	}
}

func generateCtlService(currentPath string) {
	list := collect(currentPath, ".dto.go")
	for _, item := range list {
		nameArr := strings.Split(item.Name, ".")
		if !strings.HasPrefix(item.Name, ".") && len(nameArr) > 0 {
			module := nameArr[0]
			generateCtl(currentPath, item.Path, module)
			generateService(currentPath, item.Path, module)
		}
	}
}

func generateCtl(currentPath, source, module string) {
	appPkg, err := getAppPkg()
	if err != nil {
		logger.Logger.Error(fmt.Sprintf("parse go.mod err: %v", err))
		logger.Logger.Error("Please execute the command `ripple g` under the same level directory of go.mod")
		return
	}

	logger.Logger.Info(fmt.Sprintf("auto parse %s annotation according to the ast", source))

	pkgNames := map[string]string{"github.com/labstack/echo/v4": "echo"}
	resolver := guess.WithMap(pkgNames)
	dfs, _ := rst.ParseSrcFile(source, resolver)

	ret := rst.GetStructDecsInStructComment(dfs, "@RippleApi")
	var routers []routerInfo
	for _, item := range ret {
		logger.Logger.Debug(fmt.Sprintf("============%s============", item.Name))
		var uri string
		var method string
		for _, line := range item.Decs {
			line := strings.Trim(rst.TrimAnnot(line), " ")
			logger.Logger.Debug(line)

			if strings.HasPrefix(line, "@Uri") {
				uri = parseKey("@Uri", line)
			} else if strings.HasPrefix(line, "@Method") {
				method = parseKey("@Method", line)
			}
		}
		if !strings.HasPrefix(item.Name, "Req") {
			logger.Logger.Error(fmt.Sprintf("req struct is error, please has prefix `Req`, ref file: %s", source))
			continue
		}
		name := strings.ReplaceAll(item.Name, "Req", "")
		routers = append(routers, routerInfo{
			ReqIdent:  fmt.Sprintf("Req%s", name),
			RespIdent: fmt.Sprintf("Resp%s", name),
			Action:    fmt.Sprintf("Action%s", name),
			Uri:       uri,
			Method:    method,
		})
	}

	// create *.controller.go
	logger.Logger.Info(fmt.Sprintf("auto generate %s.controller.go, ref file: %s", module, source))
	pkg := "v1"
	dir := path.Join(currentPath, "internal", "controllers", pkg)
	err = os.MkdirAll(dir, Permissions)
	if err != nil {
		logger.Logger.Error(fmt.Sprintf("The project path could not be created: %s", err))
		return
	}
	target := filepath.Join(dir, fmt.Sprintf("%s.controller.go", module))
	logger.Logger.Notice(fmt.Sprintf("check: %s, file exist: %t", target, utils.Exist(target)))

	upper := utils.StartToUpper(module)
	if !utils.Exist(target) {
		// create file, write code to file
		_, err := os.Create(target)
		if err != nil {
			logger.Logger.Error(fmt.Sprintf("%s not be created: %v", target, err))
			return
		}
		logger.Logger.Info(fmt.Sprintf("file: %s, create success", target))

		code := fmt.Sprintf(`// Code generated by ripple g, You can edit it again.
// source: %s

package %s

import (
	"github.com/labstack/echo/v4"
)

type %[3]sController struct {
	Group *echo.Group
	BaseController
}

func (this %[3]sController) Setup() {}
		`, source, pkg, upper)
		err = ioutil.WriteFile(target, []byte(code), Permissions)
		if err != nil {
			logger.Logger.Error(fmt.Sprintf("%s not be write: %v", target, err))
			return
		}
	}

	// convert to ast, append action && setup uri
	df, err := rst.ParseSrcFile(target, resolver)
	if err != nil {
		logger.Logger.Error(fmt.Sprintf("file: %s, file syntax error, convert to ast error: %v", target, err))
		return
	}
	logger.Logger.Info(fmt.Sprintf("file: %s, convert to ast success", target))

	for _, item := range routers {
		// Action
		hasAction := rst.HasFuncDeclWithRecvInFile(df, dst.FuncDecl{
			Name: &dst.Ident{Name: item.Action},
		}, fmt.Sprintf("%sController", upper))
		hasResp := rst.HasStructDeclInFile(dfs, item.RespIdent)
		if !hasResp {
			logger.Logger.Error(fmt.Sprintf("resp struct is error, you must have the corresponding Resp struct: %s, ref file: %s", item.RespIdent, source))
		}
		if !hasAction && hasResp {
			fd := createActionFunc(appPkg, currentPath, upper, item)
			df.Decls = append(df.Decls, fd)
		}

		// Setup
		routeStmt := &dst.ExprStmt{
			X: &dst.CallExpr{
				Fun: &dst.SelectorExpr{
					X: &dst.SelectorExpr{
						X:   dst.NewIdent("this"),
						Sel: dst.NewIdent("Group"),
					},
					Sel: dst.NewIdent(item.Method),
				},
				Args: []dst.Expr{
					&dst.BasicLit{Kind: token.STRING, Value: strconv.Quote(item.Uri)},
					&dst.SelectorExpr{X: dst.NewIdent("this"), Sel: dst.NewIdent(item.Action)},
				},
			},
		}
		hasRouteStmt := rst.HasStmtInsideFuncBodyWithRecv(df, fmt.Sprintf("%sController", upper), "Setup", routeStmt)
		if !hasRouteStmt {
			rst.AddStmtToFuncBodyEndWithRecv(df, fmt.Sprintf("%sController", upper), "Setup", routeStmt)
		}
	}

	buf := rst.PrintToBuf(df, resolver, []rst.PkgAlias{})
	err = ioutil.WriteFile(target, buf.Bytes(), Permissions)
	if err != nil {
		logger.Logger.Error(fmt.Sprintf("%s not be write: %v", target, err))
	}
}

func generateService(currentPath string, source, module string) {
	logger.Logger.Info(fmt.Sprintf("auto generate %s.service.go, ref file: %s", module, source))

	pkg := "services"
	dir := path.Join(currentPath, "internal", pkg)
	err := os.MkdirAll(dir, Permissions)
	if err != nil {
		logger.Logger.Error(fmt.Sprintf("The project path could not be created: %s", err))
	}
	target := filepath.Join(dir, fmt.Sprintf("%s.service.go", module))
	logger.Logger.Notice(fmt.Sprintf("check: %s, file exist: %t", target, utils.Exist(target)))

	lower := utils.StartToLower(module)
	upper := utils.StartToUpper(module)
	if !utils.Exist(target) {
		// create file, write code to file
		_, err := os.Create(target)
		if err != nil {
			logger.Logger.Error(fmt.Sprintf("%s not be created: %v", target, err))
			return
		}
		logger.Logger.Info(fmt.Sprintf("file: %s, create success", target))

		code := fmt.Sprintf(`// Code generated by ripple g, You can edit it again.
// source: %s

package %s

import (
	"github.com/labstack/echo/v4"
	"sync"
)

var (
	%[3]sService     *%[4]sService
	%[3]sServiceOnce sync.Once
)

// Get%[4]sService 单例
func Get%[4]sService(ctx echo.Context) *%[4]sService {
	%[3]sServiceOnce.Do(func() {
		%[3]sService = &%[4]sService{}
	})
	%[3]sService.ctx = ctx
	return %[3]sService
}

type %[4]sService struct {
	ctx echo.Context
}
		`, source, pkg, lower, upper)

		err = ioutil.WriteFile(target, []byte(code), Permissions)
		if err != nil {
			logger.Logger.Error(fmt.Sprintf("%s not be write: %v", target, err))
			return
		}
	}
}

//=================================================================
//                        common
//=================================================================

type fileInfo struct {
	Name string
	Path string
}

type routerInfo struct {
	ReqIdent  string
	RespIdent string

	Action string
	Uri    string
	Method string
}

// collect files with suffix in current path
func collect(currentPath string, suffix string) (list []fileInfo) {
	err := filepath.Walk(currentPath, func(file string, info fs.FileInfo, err error) error {
		if info == nil || info.IsDir() {
			return err
		}
		if strings.HasSuffix(file, suffix) {
			list = append(list, fileInfo{
				Name: info.Name(),
				Path: file,
			})
		}
		return nil
	})
	if err != nil {
		fmt.Println(fmt.Sprintf("filepath.Walk err: %v", err))
	}
	return list
}

func parseKey(key, line string) (uri string) {
	arr := strings.Split(line, " ")
	if len(arr) >= 2 {
		if strings.EqualFold(key, arr[0]) {
			uri = arr[1]
		}
	}
	return uri
}

func getAppPkg() (string, error) {
	bytes, err := ioutil.ReadFile("go.mod")
	if err != nil {
		return "", err
	}
	modFile, err := modfile.Parse("go.mod", bytes, nil)
	if err != nil {
		return "", err
	}
	return modFile.Module.Mod.Path, nil
}

func createActionFunc(appPkg, currentPath, moduleUpper string, router routerInfo) *dst.FuncDecl {
	return &dst.FuncDecl{
		Name: dst.NewIdent(router.Action),
		Recv: &dst.FieldList{
			List: []*dst.Field{
				{Names: []*dst.Ident{dst.NewIdent("this")}, Type: dst.NewIdent(fmt.Sprintf("%sController", moduleUpper))},
			},
		},
		Type: &dst.FuncType{
			Params: &dst.FieldList{
				List: []*dst.Field{
					{
						Names: []*dst.Ident{dst.NewIdent("ctx")},
						Type: &dst.SelectorExpr{
							X:   &dst.Ident{Name: "echo"},
							Sel: &dst.Ident{Name: "Context"},
						},
					},
				},
			},
			Results: &dst.FieldList{
				List: []*dst.Field{
					{Type: dst.NewIdent("error")},
				},
			},
		},
		Body: &dst.BlockStmt{
			Decs: dst.BlockStmtDecorations{Lbrace: dst.Decorations{"\n"}},
			List: []dst.Stmt{
				&dst.AssignStmt{
					Lhs: []dst.Expr{dst.NewIdent("params")},
					Tok: token.DEFINE,
					Rhs: []dst.Expr{&dst.UnaryExpr{
						Op: token.AND,
						X: &dst.CompositeLit{
							Type: &dst.Ident{
								Name: router.ReqIdent,
								Path: filepath.Join(appPkg, currentPath, "internal", "dto"),
							},
						},
					}},
				},
				&dst.AssignStmt{
					Lhs: []dst.Expr{dst.NewIdent("err")},
					Tok: token.DEFINE,
					Rhs: []dst.Expr{
						&dst.CallExpr{
							Fun:  &dst.SelectorExpr{X: dst.NewIdent("ctx"), Sel: dst.NewIdent("Bind")},
							Args: []dst.Expr{dst.NewIdent("params")},
						},
					},
				},
				&dst.IfStmt{
					Decs: dst.IfStmtDecorations{
						NodeDecs: dst.NodeDecs{
							After: dst.EmptyLine,
						},
					},
					Cond: &dst.BinaryExpr{X: dst.NewIdent("err"), Op: token.NEQ, Y: dst.NewIdent("nil")},
					Body: &dst.BlockStmt{
						List: []dst.Stmt{
							&dst.ReturnStmt{
								Results: []dst.Expr{
									&dst.CallExpr{
										Fun: &dst.SelectorExpr{
											X:   dst.NewIdent("ctx"),
											Sel: dst.NewIdent("JSON"),
										},
										Args: []dst.Expr{
											&dst.SelectorExpr{
												X:   dst.NewIdent("http"),
												Sel: dst.NewIdent("StatusOK"),
											},
											&dst.CallExpr{
												Fun: &dst.Ident{
													Name: "ErrorJSON",
													Path: filepath.Join(appPkg, currentPath, "internal", "helper"),
												},
												Args: []dst.Expr{
													&dst.Ident{
														Name: "ErrorMsgParamsValidateFailed",
														Path: filepath.Join(appPkg, currentPath, "internal", "helper"),
													},
													&dst.Ident{
														Name: "ErrorCodeParamsValidateFailed",
														Path: filepath.Join(appPkg, currentPath, "internal", "helper"),
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				&dst.AssignStmt{
					Decs: dst.AssignStmtDecorations{NodeDecs: dst.NodeDecs{Start: []string{"// TODO: add some code"}}},
					Lhs:  []dst.Expr{dst.NewIdent("result")},
					Tok:  token.DEFINE,
					Rhs: []dst.Expr{&dst.UnaryExpr{
						Op: token.AND,
						X: &dst.CompositeLit{
							Type: &dst.Ident{
								Name: router.RespIdent,
								Path: filepath.Join(appPkg, currentPath, "internal", "dto"),
							},
						},
					}},
				},
				&dst.ReturnStmt{
					Results: []dst.Expr{
						&dst.CallExpr{
							Fun: &dst.SelectorExpr{
								X:   dst.NewIdent("ctx"),
								Sel: dst.NewIdent("JSON"),
							},
							Args: []dst.Expr{
								&dst.Ident{Name: "StatusOK", Path: "net/http"},
								&dst.CallExpr{
									Fun: &dst.Ident{
										Name: "SuccessJSON",
										Path: filepath.Join(appPkg, currentPath, "internal", "helper"),
									},
									Args: []dst.Expr{dst.NewIdent("result")},
								},
							},
						},
					},
				},
			},
		},
		Decs: dst.FuncDeclDecorations{NodeDecs: dst.NodeDecs{Before: dst.EmptyLine}},
	}
}
